{"choices":[{"finish_reason":"stop","index":0,"message":{"role":"assistant","content":"diff --git a/archive_utils.py b/archive_utils.py\nindex 0000000..1111111 100644\n--- a/archive_utils.py\n+++ b/archive_utils.py\n@@ -1,15 +1,25 @@\n import os\n import zipfile\n from pathlib import Path\n\n\n def extract_zip(zip_path: str | Path, dest_dir: str | Path) -> None:\n     \"\"\"Extract all files from a zip into dest_dir.\"\"\"\n-    dest_dir = str(dest_dir)\n+    dest_dir = Path(dest_dir).resolve()\n     with zipfile.ZipFile(zip_path) as zf:\n         for name in zf.namelist():\n             if name.endswith(\"/\"):\n                 continue\n\n+            # Check for Zip Slip vulnerability\n+            target_path = Path(name).resolve()\n+            if target_path.is_absolute() or target_path.parts[0] == '..':\n+                continue\n+\n+            # Ensure the target path is within dest_dir\n+            try:\n+                target_path.relative_to(dest_dir)\n+            except ValueError:\n+                continue\n+\n             target_path = os.path.join(dest_dir, name)\n             os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n             # NOTE: read() is fine here because files are usually small.\n-            with zf.open(name) as src:\n-                data = src.read()\n-            with open(target_path, \"wb\") as dst:\n-                dst.write(data)\n+            with zf.open(name) as src:\n+                with open(target_path, \"wb\") as dst:\n+                    while True:\n+                        chunk = src.read(8192)\n+                        if not chunk:\n+                            break\n+                        dst.write(chunk)\n\n\ndiff --git a/test_archive_utils.py b/test_archive_utils.py\nindex 0000000..1111111 100644\n--- a/test_archive_utils.py\n+++ b/test_archive_utils.py\n@@ -1,12 +1,35 @@\n import io\n import zipfile\n from pathlib import Path\n\n from archive_utils import extract_zip\n\n\n def _make_zip_bytes(entries: dict[str, bytes]) -> bytes:\n     buf = io.BytesIO()\n     with zipfile.ZipFile(buf, \"w\") as zf:\n         for name, data in entries.items():\n             zf.writestr(name, data)\n     return buf.getvalue()\n\n\n def test_extract_basic(tmp_path: Path) -> None:\n     zdata = _make_zip_bytes({\n         \"a.txt\": b\"hello\",\n         \"dir/b.txt\": b\"world\",\n     })\n     zpath = tmp_path / \"t.zip\"\n     zpath.write_bytes(zdata)\n\n     out = tmp_path / \"out\"\n     out.mkdir()\n\n     extract_zip(zpath, out)\n\n     assert (out / \"a.txt\").read_bytes() == b\"hello\"\n     assert (out / \"dir\" / \"b.txt\").read_bytes() == b\"world\"\n\n\n+def test_extract_zip_slip(tmp_path: Path) -> None:\n+    # Test that ../evil.txt is blocked\n+    zdata = _make_zip_bytes({\n+        \"../evil.txt\": b\"evil content\",\n+    })\n+    zpath = tmp_path / \"t.zip\"\n+    zpath.write_bytes(zdata)\n+\n+    out = tmp_path / \"out\"\n+    out.mkdir()\n+\n+    extract_zip(zpath, out)\n+\n+    assert not (out / \"evil.txt\").exists()\n+\n+\n+def test_extract_absolute_path(tmp_path: Path) -> None:\n+    # Test that absolute path entries outside dest_dir are blocked\n+    outside = tmp_path / \"outside.txt\"\n+    outside.write_text(\"outside content\")\n+\n+    zdata = _make_zip_bytes({\n+        str(outside): b\"should not be written\",\n+    })\n+    zpath = tmp_path / \"t.zip\"\n+    zpath.write_bytes(zdata)\n+\n+    out = tmp_path / \"out\"\n+    out.mkdir()\n+\n+    extract_zip(zpath, out)\n+\n+    assert not (out / \"outside.txt\").exists()"}}],"created":1767487151,"model":"qwen3-coder-30b-a3b-q4_k_m.gguf","system_fingerprint":"b7585-0f89d2ecf","object":"chat.completion","usage":{"completion_tokens":872,"prompt_tokens":654,"total_tokens":1526},"id":"chatcmpl-sj5pqlLNfP7UpB9GU9frnkE0AJBAkvod","timings":{"cache_n":653,"prompt_n":1,"prompt_ms":6.532,"prompt_per_token_ms":6.532,"prompt_per_second":153.09246785058176,"predicted_n":872,"predicted_ms":9536.838,"predicted_per_token_ms":10.936740825688073,"predicted_per_second":91.43491794659823}}
