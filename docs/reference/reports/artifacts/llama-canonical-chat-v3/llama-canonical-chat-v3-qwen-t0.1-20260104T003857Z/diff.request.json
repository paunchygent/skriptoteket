{
  "model": "qwen3-coder-30b-a3b-q4_k_m.gguf",
  "messages": [
    {
      "role": "system",
      "content": "You are a senior Python engineer. Follow instructions exactly. Never use markdown code fences (no triple backticks)."
    },
    {
      "role": "user",
      "content": "CANONICAL BENCHMARK v3 - STEP 2 (PATCH)\n\nTask: produce a patch as a unified diff.\n\nStrict output rules:\n- Output ONLY a unified diff. No prose. No preamble. No explanations.\n- Do not output any triple backticks.\n- The FIRST line of your output MUST be exactly:\n  diff --git a/archive_utils.py b/archive_utils.py\n- If you cannot comply, output exactly: CANNOT_COMPLY\n\nPatch requirements:\n- Fix Zip Slip / path traversal: no zip entry may write outside dest_dir.\n- For unsafe entries (absolute paths OR paths that escape dest_dir), SKIP them and continue.\n- Do not read entire files into memory; stream copy.\n- Keep behavior: directory entries in the zip should be ignored.\n- Add 2 tests:\n  1) A \"../evil.txt\" entry is blocked (should NOT create tmp_path/evil.txt).\n  2) An absolute-path entry is blocked using a path under tmp_path but OUTSIDE the out/ dir:\n     outside = tmp_path / \"outside.txt\"; zip entry name should be str(outside).\n\nDiff headers must use these file names:\n- a/archive_utils.py b/archive_utils.py\n- a/test_archive_utils.py b/test_archive_utils.py\n\nOriginal files:\n\nFILE: archive_utils.py\nimport os\nimport zipfile\nfrom pathlib import Path\n\n\ndef extract_zip(zip_path: str | Path, dest_dir: str | Path) -> None:\n    \"\"\"Extract all files from a zip into dest_dir.\"\"\"\n    dest_dir = str(dest_dir)\n    with zipfile.ZipFile(zip_path) as zf:\n        for name in zf.namelist():\n            if name.endswith(\"/\"):\n                continue\n\n            target_path = os.path.join(dest_dir, name)\n            os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n            # NOTE: read() is fine here because files are usually small.\n            with zf.open(name) as src:\n                data = src.read()\n            with open(target_path, \"wb\") as dst:\n                dst.write(data)\n\n\nFILE: test_archive_utils.py\nimport io\nimport zipfile\nfrom pathlib import Path\n\nfrom archive_utils import extract_zip\n\n\ndef _make_zip_bytes(entries: dict[str, bytes]) -> bytes:\n    buf = io.BytesIO()\n    with zipfile.ZipFile(buf, \"w\") as zf:\n        for name, data in entries.items():\n            zf.writestr(name, data)\n    return buf.getvalue()\n\n\ndef test_extract_basic(tmp_path: Path) -> None:\n    zdata = _make_zip_bytes({\n        \"a.txt\": b\"hello\",\n        \"dir/b.txt\": b\"world\",\n    })\n    zpath = tmp_path / \"t.zip\"\n    zpath.write_bytes(zdata)\n\n    out = tmp_path / \"out\"\n    out.mkdir()\n\n    extract_zip(zpath, out)\n\n    assert (out / \"a.txt\").read_bytes() == b\"hello\"\n    assert (out / \"dir\" / \"b.txt\").read_bytes() == b\"world\"\n"
    }
  ],
  "max_tokens": 1024,
  "temperature": 0.1,
  "min_p": 0.01,
  "top_p": 0.8,
  "stream": false,
  "seed": 42,
  "top_k": 20,
  "repeat_penalty": 1.05
}
